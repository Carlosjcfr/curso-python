import random

def miller_rabin(n, k=10):
    """
    Determina si n es primo con una probabilidad de error de (1/4)^k.
    k es el número de intentos o 'testigos'.
    """
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0: return False

    # 1. Escribir n-1 como 2^s * d
    # Factorizamos todos los doses posibles de n-1
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1

    # 2. Realizar k pruebas
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, d, n) # Esto es a^d % n (eficiencia pura)

        if x == 1 or x == n - 1:
            continue
            
        for _ in range(s - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False # Es compuesto con total seguridad

    return True # Es "probablemente" primo

# Tu número gigante (agregué un +7 para que sea impar, porque 10^60 es par y no es primo)
n_gigante = 10**60 + 7 

if miller_rabin(n_gigante):
    print(f"El número {n_gigante} es PROBABLEMENTE PRIMO.")
else:
    print(f"El número {n_gigante} es COMPUESTO.")